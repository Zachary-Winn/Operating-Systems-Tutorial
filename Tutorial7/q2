#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>

#define NUM_LINES 10

struct proc {
	char name[255];
	int priority;
	int pid;
	time_t runtime;
};

struct queue {
	struct proc process;
	struct queue *next;
};

struct queue *head = NULL, *current;

int push(struct proc pushedProcess) {

	struct queue * new;

	if(head == NULL){

		new = malloc(sizeof(struct queue));
		new->next = NULL;
		new->process=pushedProcess;
		head = new;
		++queueSize;

	}

	else {

		current = head;

		//while current isnt the last element move to the next element
		while(current->next != NULL) {

			current = current->next;
		}

		//after current reached the last element, current points to the new element
		new = malloc(sizeof(struct queue));
		current->next = new;
		new->process = pushedProcess;
		new->next = NULL;
		++queueSize;
	}

	return 0;
}

//Removes the first entry from our queue and returns it's process
proc *pop() {

	queue *cur_node;
	proc *process;
	
	//Check if empty queue
	if(linked_list == NULL) {

		return NULL;
	}
	
	//Get the current head
	cur_node = linked_list;
	
	//Get the process info
	process = cur_node->process;
	
	//Update the head
	linked_list = cur_node->next;
	
	//Free the memory
	free(cur_node);
	
	//Return the process info of the node removed
	return process;
}

//Removes the entry with the specified name and returns it's process
proc *delete_name(char *name) {

	queue *cur_node, *removal_node;
	proc *process;
	
	//Check if empty queue
	if(linked_list == NULL) {

		return NULL;
	}
	
	//Get the current head
	cur_node = linked_list;
	
	//Get the process of the head
	process = cur_node->process;
	
	//Check if process being removed is at the head
	if(!strcmp(process->name, name)) {
		
		//Set the new head
		linked_list = cur_node->next;
		
		//Free the memory of the removal node
		free(cur_node);
			
		//Return the process that was just removed
		return process;
	}
	
	//Go through the queue
	while(cur_node->next != NULL) {
		
		//Get the process info
		process = cur_node->next->process;
		
		//Check if name was a match
		if(!strcmp(process->name, name)) {
			
			//Get the node being removed
			removal_node = cur_node->next;
						
			//Set the new next node
			cur_node->next = removal_node->next;
			
			//Free the memory of the removal node
			free(removal_node);
			
			//Return the process that was just removed
			return process;
		}
		
		//Get the next node
		cur_node = cur_node->next;
	}
	
	//Return process not found
	return NULL;
}

//Removes the entry with the specified process id and returns it's process
proc *delete_pid(int pid) {

	queue *cur_node, *removal_node;
	proc *process;
	
	//Check if empty queue
	if(linked_list == NULL) {

		return NULL;
	}
	
	//Get the current head
	cur_node = linked_list;
	
	//Get the process of the head
	process = cur_node->process;
	
	//Check if process being removed is at the head
	if(process->pid == pid) {
		
		//Set the new head
		linked_list = cur_node->next;
		
		//Free the memory of the removal node
		free(cur_node);
			
		//Return the process that was just removed
		return process;
	}
	
	//Go through the queue
	while(cur_node->next != NULL) {
		
		//Get the process info
		process = cur_node->next->process;
		
		//Check if name was a match
		if(process->pid == pid) {
			
			//Get the node being removed
			removal_node = cur_node->next;
						
			//Set the new next node
			cur_node->next = removal_node->next;
			
			//Free the memory of the removal node
			free(removal_node);
			
			//Return the process that was just removed
			return process;
		}
		
		//Get the next node
		cur_node = cur_node->next;
	}
	
	//Return process not found
	return NULL;
}

int main(void) {

	FILE *fp;
    const char delim[2] =",";
    char buffer[255];
    char * token;

	proc *newproc;
	queue *cur_node;

    printf("opening file\n");
	fp = fopen("processes.txt", "r");
    int charCounter = 0, c;
	
    for(int i = 0;i<10;i++) {// for each line in the text file

		while((c = fgetc(fp) )!= '\n') {

			//while it is not the next line keep grabbing character
			buffer[charCounter++] = c;
		}

		charCounter = 0;

		//when a full line has been placed into the buffer split the line by , delim
		token = strtok(buffer,delim);

		struct proc *newproc;
		newproc = malloc(sizeof(struct proc));

		//for each of the 4 elemets of the proc structure
		for(int j =0;j<4;j++) {

			switch(j) {

				case 0: strcpy(newproc->name,token);break;
				case 1: newproc->priority = atoi(token);break;
				case 2: newproc->pid = atoi(token);break;
				case 3: newproc->runtime = atoi(token);break;
				default:printf("this should not be seen\n");return 1;
			}

			token = strtok(NULL,delim);
		}

		//clean the buffer
		for(int c = 0; c<255;c++) {

			buffer[c] = ' ';
		}

		push(*newproc);//push new proc to queue
	}//end for
	
	//Remove the emacs process
	process = delete_name("emacs");
	
	//Check if error
	if(process == NULL) {

		printf("ERROR: emacs process not found\n");

		return -1;
	}
	
	//Display the removed process info
	printf("Removed by name: %s, %d, %d, %d\n", process->name, process->priority, process->pid, process->runtime);
	
	//Remove the process with id 12235
	process = delete_pid(12235);
	
	//Check if error
	if(process == NULL) {

		printf("ERROR: process with id 12235 not found\n");

		return -1;
	}
	
	//Display the removed process info
	printf("Removed by id: %s, %d, %d, %d\n", process->name, process->priority, process->pid, process->runtime);
	
	//Remove all the processes in the queue
	while((process = pop()) != NULL) {

		printf("%s, %d, %d, %d\n", process->name, process->priority, process->pid, process->runtime);
	}
	
	//Close the file
	fclose(fp);
	
	return 0;
}
